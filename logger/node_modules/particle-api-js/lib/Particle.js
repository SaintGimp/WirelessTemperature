'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

require('babel-polyfill');

var _superagent = require('superagent');

var _superagent2 = _interopRequireDefault(_superagent);

var _superagentPrefix = require('superagent-prefix');

var _superagentPrefix2 = _interopRequireDefault(_superagentPrefix);

var _Defaults = require('./Defaults');

var _Defaults2 = _interopRequireDefault(_Defaults);

var _EventStream = require('./EventStream');

var _EventStream2 = _interopRequireDefault(_EventStream);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Particle = function () {
	function Particle() {
		var options = arguments.length <= 0 || arguments[0] === undefined ? _Defaults2.default : arguments[0];

		_classCallCheck(this, Particle);

		Object.assign(this, options);
		this.prefix = (0, _superagentPrefix2.default)(this.baseUrl);
	}

	/**
  * Login to Particle Cloud using an existing Particle acccount.
  * @param  {String} $0.username      Username for the Particle account
  * @param  {String} $0.password      Password for the Particle account
  * @param  {Number} $0.tokenDuration How long the access token should last in seconds
  * @return {Promise}
  */


	_createClass(Particle, [{
		key: 'login',
		value: function login(_ref) {
			var username = _ref.username;
			var password = _ref.password;
			var _ref$tokenDuration = _ref.tokenDuration;
			var tokenDuration = _ref$tokenDuration === undefined ? this.tokenDuration : _ref$tokenDuration;

			return this.request({ uri: '/oauth/token', form: {
					username: username,
					password: password,
					grant_type: 'password',
					client_id: this.clientId,
					client_secret: this.clientSecret,
					expires_in: tokenDuration
				}, method: 'post' });
		}

		/**
   * Create a user account for the Particle Cloud
   * @param  {String} $0.username Desired username
   * @param  {String} $0.password Password
   * @return {Promise}
   */

	}, {
		key: 'createUser',
		value: function createUser(_ref2) {
			var username = _ref2.username;
			var password = _ref2.password;

			return this.post('/v1/users', {
				username: username, password: password
			});
		}

		/**
   * Revoke an access token
   * @param  {String} $0.username Username of the Particle cloud account that the token belongs to.
   * @param  {String} $0.password Password for the account
   * @param  {String} $0.token    Access token you wish to revoke
   * @return {Promise}
   */

	}, {
		key: 'removeAccessToken',
		value: function removeAccessToken(_ref3) {
			var username = _ref3.username;
			var password = _ref3.password;
			var token = _ref3.token;

			return this.delete('/v1/access_tokens/' + token, {
				access_token: token
			}, { username: username, password: password });
		}

		/**
   * List all valid access tokens for a Particle Cloud account
   * @param  {String} $0.username Username
   * @param  {String} $0.password Password
   * @return {Promise}
   */

	}, {
		key: 'listAccessTokens',
		value: function listAccessTokens(_ref4) {
			var username = _ref4.username;
			var password = _ref4.password;

			return this.get('/v1/access_tokens', { username: username, password: password });
		}

		/**
   * List devices claimed to the account
   * @param  {String} $0.auth Access Token
   * @return {Promise}
   */

	}, {
		key: 'listDevices',
		value: function listDevices(_ref5) {
			var auth = _ref5.auth;

			return this.get('/v1/devices', auth);
		}

		/**
   * Get detailed informationa about a device
   * @param  {String} $0.deviceId Device ID or Name
   * @param  {String} $0.auth     Access token
   * @return {Promise}
   */

	}, {
		key: 'getDevice',
		value: function getDevice(_ref6) {
			var deviceId = _ref6.deviceId;
			var auth = _ref6.auth;

			return this.get('/v1/devices/' + deviceId, auth);
		}

		/**
   * Claim a device to the account. The device must be online and unclaimed.
   * @param  {String} $0.deviceId Device ID
   * @param  {String} $0.auth     Access Token
   * @return {Promise}
   */

	}, {
		key: 'claimDevice',
		value: function claimDevice(_ref7) {
			var deviceId = _ref7.deviceId;
			var requestTransfer = _ref7.requestTransfer;
			var auth = _ref7.auth;

			return this.request({ uri: '/v1/devices', form: {
					id: deviceId,
					request_transfer: !!requestTransfer
				}, auth: auth, method: 'post' });
		}

		/**
   * Unclaim / Remove a device from your account
   * @param  {String} $0.deviceId Device ID or Name
   * @param  {String} $0.auth     Access Token
   * @return {Promise}
   */

	}, {
		key: 'removeDevice',
		value: function removeDevice(_ref8) {
			var deviceId = _ref8.deviceId;
			var auth = _ref8.auth;

			return this.delete('/v1/devices/' + deviceId, null, auth);
		}

		/**
   * Rename a device
   * @param  {String} $0.deviceId Device ID or Name
   * @param  {String} $0.name     Desired Name
   * @param  {String} $0.auth     Access Token
   * @return {Promise}
   */

	}, {
		key: 'renameDevice',
		value: function renameDevice(_ref9) {
			var deviceId = _ref9.deviceId;
			var name = _ref9.name;
			var auth = _ref9.auth;

			return this.put('/v1/devices/' + deviceId, { name: name }, auth);
		}

		/**
   * Generate a claim code to use in the device claiming process.
   * @param  {String} $0.auth  Access Token
   * @param  {String} [$0.iccid] ICCID of the SIM card used in the Electron
   * @return {Promise}
   */

	}, {
		key: 'getClaimCode',
		value: function getClaimCode(_ref10) {
			var auth = _ref10.auth;
			var _ref10$iccid = _ref10.iccid;
			var iccid = _ref10$iccid === undefined ? undefined : _ref10$iccid;

			return this.post('/v1/device_claims', { iccid: iccid }, auth);
		}
	}, {
		key: 'validatePromoCode',
		value: function validatePromoCode(_ref11) {
			var auth = _ref11.auth;
			var promoCode = _ref11.promoCode;

			return this.get('/v1/promo_code/' + promoCode, auth);
		}
	}, {
		key: 'changeProduct',
		value: function changeProduct(_ref12) {
			var deviceId = _ref12.deviceId;
			var productId = _ref12.productId;
			var shouldUpdate = _ref12.shouldUpdate;
			var auth = _ref12.auth;

			return this.put('/v1/devices/' + deviceId, {
				product_id: productId,
				update_after_claim: shouldUpdate || false
			}, auth);
		}

		/**
   * Get the value of a device variable
   * @param  {String} $0.deviceId Device ID or Name
   * @param  {String} $0.name     Variable name
   * @param  {String} $0.auth     Access Token
   * @return {Promise}
   */

	}, {
		key: 'getVariable',
		value: function getVariable(_ref13) {
			var deviceId = _ref13.deviceId;
			var name = _ref13.name;
			var auth = _ref13.auth;

			return this.get('/v1/devices/' + deviceId + '/' + name, auth);
		}

		/**
   * Instruct the device to turn on/off the LED in a rainbow pattern
   * @param  {String} $0.deviceId Device ID or Name
   * @param  {Boolean} $0.signal   Signal on or off
   * @param  {String} $0.auth     Access Token
   * @return {Promise}
   */

	}, {
		key: 'signalDevice',
		value: function signalDevice(_ref14) {
			var deviceId = _ref14.deviceId;
			var signal = _ref14.signal;
			var auth = _ref14.auth;

			return this.put('/v1/devices/' + deviceId, {
				signal: !!signal ? '1' : '0'
			}, auth);
		}

		/**
   * Compile and flash application firmware to a device
   * @param  {String} $0.deviceId      Device ID or Name
   * @param  {Object} $0.files         Object containing files to be compiled. Keys should be the filenames, and the values should be a path or Buffer of the file contents.
   * @param  {String} [$0.targetVersion=latest] System firmware version to compile against
   * @param  {String} $0.auth          String
   * @return {Promise}
   */

	}, {
		key: 'flashDevice',
		value: function flashDevice(_ref15) {
			var deviceId = _ref15.deviceId;
			var files = _ref15.files;
			var targetVersion = _ref15.targetVersion;
			var auth = _ref15.auth;

			var form = {};
			if (targetVersion) {
				form.build_target_version = targetVersion;
			} else {
				form.latest = 'true';
			}
			return this.request({ uri: '/v1/devices/' + deviceId,
				files: files, auth: auth, form: form, method: 'put' });
		}

		/**
   * Flash the Tinker application to a device
   * @param  {String} $0.deviceId Device ID or Name
   * @param  {String} $0.auth     Access Token
   * @return {Promise}
   */

	}, {
		key: 'flashTinker',
		value: function flashTinker(_ref16) {
			var deviceId = _ref16.deviceId;
			var auth = _ref16.auth;

			return this.put('/v1/devices/' + deviceId, {
				app: 'tinker'
			}, auth);
		}

		/**
   * Compile firmware using the Particle Cloud
   * @param  {Object} $0.files         Object containing files to be compiled. Keys should be the filenames, and the values should be a path or Buffer of the file contents.
   * @param  {Number} [$0.platformId]    Platform id number of the device you are compiling for. Common values are 0=Core, 6=Photon, 10=Electron.
   * @param  {String} [$0.targetVersion=latest] System firmware version to compile against
   * @param  {String} $0.auth          Access Token
   * @return {Promise}
   */

	}, {
		key: 'compileCode',
		value: function compileCode(_ref17) {
			var files = _ref17.files;
			var platformId = _ref17.platformId;
			var targetVersion = _ref17.targetVersion;
			var auth = _ref17.auth;

			var form = { platform_id: platformId };
			if (targetVersion) {
				form.build_target_version = targetVersion;
			} else {
				form.latest = 'true';
			}
			return this.request({ uri: '/v1/binaries',
				files: files, auth: auth, form: form, method: 'post' });
		}

		/**
   * Download a firmware binary
   * @param  {String} $0.binaryId Binary ID received from a successful compile call
   * @param  {String} $0.auth     Access Token
   * @return {Request}
   */

	}, {
		key: 'downloadFirmwareBinary',
		value: function downloadFirmwareBinary(_ref18) {
			var binaryId = _ref18.binaryId;
			var auth = _ref18.auth;

			var uri = '/v1/binaries/' + binaryId;
			var req = (0, _superagent2.default)('get', uri);
			req.use(this.prefix);
			this.headers(req, auth);
			if (this.debug) {
				this.debug(req);
			}
			return req;
		}

		/**
   * Send a new device public key to the Particle Cloud
   * @param  {String} $0.deviceId  Device ID or Name
   * @param  {(String|Buffer)} $0.key       Public key contents
   * @param  {String} [$0.algorithm=rsa] Algorithm used to generate the public key. Valid values are `rsa` or `ecc`.
   * @param  {String} $0.auth      Access Token
   * @return {Promise}
   */

	}, {
		key: 'sendPublicKey',
		value: function sendPublicKey(_ref19) {
			var deviceId = _ref19.deviceId;
			var key = _ref19.key;
			var algorithm = _ref19.algorithm;
			var auth = _ref19.auth;

			return this.post('/v1/provisioning/' + deviceId, {
				deviceID: deviceId,
				publicKey: typeof key === 'string' ? key : key.toString(),
				filename: 'particle-api',
				order: 'manual_' + Date.now(),
				algorithm: algorithm || 'rsa'
			}, auth);
		}

		/**
   * Call a device function
   * @param  {String} $0.deviceId Device ID or Name
   * @param  {String} $0.name     Function name
   * @param  {String} $0.argument Function argument
   * @param  {String} $0.auth     Access Token
   * @return {Promise}
   */

	}, {
		key: 'callFunction',
		value: function callFunction(_ref20) {
			var deviceId = _ref20.deviceId;
			var name = _ref20.name;
			var argument = _ref20.argument;
			var auth = _ref20.auth;

			return this.post('/v1/devices/' + deviceId + '/' + name, {
				args: argument
			}, auth);
		}

		/**
   * Get a stream of events
   * @param  {String} [$0.deviceId] Device ID or Name, or `mine` to indicate only your devices.
   * @param  {String} [$0.name]     Event Name
   * @param  {String} [$0.org]     Organization Slug
   * @param  {String} [$0.product]     Product Slug
   * @param  {String} $0.auth     Access Token
   * @return {Promise} If the promise resolves, the resolution value will be an EventStream object that will
   * emit 'event' events, as well as the specific named event.
   */

	}, {
		key: 'getEventStream',
		value: function getEventStream(_ref21) {
			var deviceId = _ref21.deviceId;
			var name = _ref21.name;
			var org = _ref21.org;
			var product = _ref21.product;
			var auth = _ref21.auth;

			var uri = '/v1/';
			if (org) {
				uri += 'orgs/' + org + '/';
				if (product) {
					uri += 'products/' + product + '/';
				} else if (deviceId && deviceId.toLowerCase() !== 'mine') {
					uri += 'devices/' + deviceId + '/';
				}
				uri += 'events';
			} else {
				if (!deviceId) {
					uri += 'events';
				} else if (deviceId.toLowerCase() === 'mine') {
					uri += 'devices/events';
				} else {
					uri += 'devices/' + deviceId + '/events';
				}
			}

			if (name) {
				uri += '/' + encodeURIComponent(name);
			}
			return new _EventStream2.default('' + this.baseUrl + uri, auth, { debug: this.debug }).connect();
		}

		/**
   * Publish a event to the Particle Cloud
   * @param  {String} $0.name      Event name
   * @param  {String} $0.data      Event data
   * @param  {Boolean} $0.isPrivate Should the event be publicly available?
   * @param  {String} $0.auth      Access Token
   * @return {Promise}
   */

	}, {
		key: 'publishEvent',
		value: function publishEvent(_ref22) {
			var name = _ref22.name;
			var data = _ref22.data;
			var isPrivate = _ref22.isPrivate;
			var auth = _ref22.auth;

			return this.post('/v1/devices/events', {
				name: name,
				data: data,
				'private': isPrivate
			}, auth);
		}

		/**
   * Create a webhook
   * @param  {String} $0.deviceId           Device ID or Name
   * @param  {String} $0.name               Webhook name
   * @param  {String} $0.url                URL the webhook should hit
   * @param  {String} [$0.requestType=POST]        HTTP method to use
   * @param  {Object} [$0.headers]            Additional headers to add to the webhook
   * @param  {Object} [$0.json]               JSON data
   * @param  {Object} [$0.query]              Query string data
   * @param  {Boolean} [$0.rejectUnauthorized] Reject invalid HTTPS certificates
   * @param  {Object} [$0.webhookAuth]        HTTP Basic Auth information
   * @param  {Object} [$0.form]               Form data
   * @param  {String} $0.auth               Access Token
   * @return {Promise}
   */

	}, {
		key: 'createWebhook',
		value: function createWebhook(_ref23) {
			var deviceId = _ref23.deviceId;
			var name = _ref23.name;
			var url = _ref23.url;
			var requestType = _ref23.requestType;
			var headers = _ref23.headers;
			var json = _ref23.json;
			var query = _ref23.query;
			var rejectUnauthorized = _ref23.rejectUnauthorized;
			var webhookAuth = _ref23.webhookAuth;
			var form = _ref23.form;
			var auth = _ref23.auth;

			var data = { event: name, url: url, requestType: requestType, headers: headers, json: json, query: query, rejectUnauthorized: rejectUnauthorized, auth: webhookAuth, form: form };
			if (deviceId === 'mine') {
				data.mydevices = true;
			} else {
				data.deviceid = deviceId;
			}
			return this.post('/v1/webhooks', data, auth);
		}

		/**
   * Delete a webhook
   * @param  {String} $0.hookId Webhook ID
   * @param  {String} $0.auth   Access Token
   * @return {Promise}
   */

	}, {
		key: 'deleteWebhook',
		value: function deleteWebhook(_ref24) {
			var hookId = _ref24.hookId;
			var auth = _ref24.auth;

			return this.delete('/v1/webhooks/' + hookId, null, auth);
		}

		/**
   * List all webhooks owned by the account
   * @param  {String} $0.auth Access Token
   * @return {Promise}
   */

	}, {
		key: 'listWebhooks',
		value: function listWebhooks(_ref25) {
			var auth = _ref25.auth;

			return this.get('/v1/webhooks', auth);
		}

		/**
   * Get details about the current user
   * @param  {String} $0.auth Access Token
   * @return {Promise}
   */

	}, {
		key: 'getUserInfo',
		value: function getUserInfo(_ref26) {
			var auth = _ref26.auth;

			return this.get('/v1/user', auth);
		}
	}, {
		key: 'setUserInfo',
		value: function setUserInfo(_ref27) {
			var stripeToken = _ref27.stripeToken;
			var auth = _ref27.auth;

			return this.put('/v1/user', {
				stripe_token: stripeToken
			}, auth);
		}
	}, {
		key: 'checkSIM',
		value: function checkSIM(_ref28) {
			var iccid = _ref28.iccid;
			var auth = _ref28.auth;

			return this.head('/v1/sims/' + iccid, auth);
		}
	}, {
		key: 'activateSIM',
		value: function activateSIM(_ref29) {
			var iccid = _ref29.iccid;
			var countryCode = _ref29.countryCode;
			var promoCode = _ref29.promoCode;
			var auth = _ref29.auth;

			return this.put('/v1/sims/' + iccid, {
				country: countryCode,
				promo_code: promoCode,
				action: 'activate'
			}, auth);
		}

		/**
   * List valid build targets to be used for compiling
   * @param  {String} $0.auth         Access Token
   * @param  {Boolean} [$0.onlyFeatured=false] Only list featured build targets
   * @return {Promise}
   */

	}, {
		key: 'listBuildTargets',
		value: function listBuildTargets(_ref30) {
			var auth = _ref30.auth;
			var _ref30$onlyFeatured = _ref30.onlyFeatured;
			var onlyFeatured = _ref30$onlyFeatured === undefined ? undefined : _ref30$onlyFeatured;

			var query = undefined;
			if (onlyFeatured !== undefined) {
				query = { featured: !!onlyFeatured };
			}
			return this.get('/v1/build_targets', auth, query);
		}
	}, {
		key: 'get',
		value: function get(uri, auth) {
			var query = arguments.length <= 2 || arguments[2] === undefined ? undefined : arguments[2];

			return this.request({ uri: uri, auth: auth, method: 'get', query: query });
		}
	}, {
		key: 'head',
		value: function head(uri, auth) {
			return this.request({ uri: uri, auth: auth, method: 'head' });
		}
	}, {
		key: 'post',
		value: function post(uri, data, auth) {
			return this.request({ uri: uri, data: data, auth: auth, method: 'post' });
		}
	}, {
		key: 'put',
		value: function put(uri, data, auth) {
			return this.request({ uri: uri, data: data, auth: auth, method: 'put' });
		}
	}, {
		key: 'delete',
		value: function _delete(uri, data, auth) {
			return this.request({ uri: uri, data: data, auth: auth, method: 'delete' });
		}
	}, {
		key: 'request',
		value: function request(_ref31) {
			var _this = this;

			var uri = _ref31.uri;
			var method = _ref31.method;
			var _ref31$data = _ref31.data;
			var data = _ref31$data === undefined ? undefined : _ref31$data;
			var auth = _ref31.auth;
			var _ref31$query = _ref31.query;
			var query = _ref31$query === undefined ? undefined : _ref31$query;
			var _ref31$form = _ref31.form;
			var form = _ref31$form === undefined ? undefined : _ref31$form;
			var _ref31$files = _ref31.files;
			var files = _ref31$files === undefined ? undefined : _ref31$files;

			return new Promise(function (fulfill, reject) {
				var req = (0, _superagent2.default)(method, uri);
				req.use(_this.prefix);
				_this.headers(req, auth);
				if (query) {
					req.query(query);
				}
				if (files) {
					Object.keys(files).forEach(function (k, i) {
						req.attach('file' + (i + 1), files[k], k);
					});
					if (form) {
						Object.keys(form).forEach(function (k) {
							req.field(k, form[k]);
						});
					}
				} else if (form) {
					req.type('form');
					req.send(form);
				} else if (data) {
					req.send(data);
				}

				if (_this.debug) {
					_this.debug(req);
				}

				req.end(function (error, res) {
					var body = res && res.body;
					if (error) {
						var statusCode = error.status;
						var errorDescription = (statusCode ? 'HTTP error' : 'Network error') + ' ' + statusCode + ' from ' + uri;
						if (body && body.error_description) {
							errorDescription += ' - ' + body.error_description;
						}
						reject({ statusCode: statusCode, errorDescription: errorDescription, error: error, body: body });
					} else {
						fulfill({
							body: body,
							statusCode: res.statusCode
						});
					}
				});
			});
		}
	}, {
		key: 'headers',
		value: function headers(req, auth) {
			if (!auth) {
				return;
			}

			if ((typeof auth === 'undefined' ? 'undefined' : _typeof(auth)) === 'object') {
				req.auth(auth.username, auth.password);
			} else {
				req.set({ Authorization: 'Bearer ' + auth });
			}
		}
	}]);

	return Particle;
}();

exports.default = Particle;
module.exports = exports['default'];
//# sourceMappingURL=Particle.js.map